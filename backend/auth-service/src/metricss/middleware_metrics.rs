//! # Middleware Metrics - HTTP Layer Observability
//!
//! Enterprise-grade metrics for HTTP middleware layers with comprehensive security observability.
//! Provides critical monitoring for authentication, rate limiting, and security policy enforcement.
//!
//! ## Design Philosophy
//! - **HTTP Decision Tracking**: Monitors middleware-specific status codes and outcomes
//! - **Security Policy Visibility**: Tracks allowed vs. blocked requests with policy context
//! - **Performance Measurement**: Monitors middleware processing latency for optimization
//! - **Low Cardinality**: Controlled label values to prevent metric explosion
//! - **Integration Ready**: Works alongside other metric modules for complete coverage
//!
//! ## Core Metrics (3 Essential)
//! - `middleware_http_responses_total`: HTTP responses by status, middleware, and endpoint
//! - `security_policy_enforcements_total`: Security policy decisions with action context
//! - `middleware_processing_duration_seconds`: Middleware performance monitoring

use crate::log_info;
use lazy_static::lazy_static;
use prometheus::{register_counter_vec, CounterVec};
use std::sync::atomic::{AtomicBool, Ordering};

lazy_static! {
    /// **Core HTTP Metric**: HTTP Responses from Middleware
    ///
    /// Tracks what HTTP status codes middleware returns to clients for comprehensive
    /// API usage and error pattern analysis.
    ///
    /// # Labels
    /// * `status_code`: HTTP status code (401, 429, 503, etc.)
    /// * `middleware_type`: Which middleware generated the response
    /// * `endpoint_group`: Logical API grouping for context
    pub static ref MIDDLEWARE_HTTP_RESPONSES: CounterVec = register_counter_vec!(
        "middleware_http_responses_total",
        "HTTP responses generated by middleware layers",
        &["status_code", "middleware_type", "endpoint_group"]
    ).expect("Failed to register middleware_http_responses_total");

    /// **Core Security Metric**: Security Policy Enforcement
    ///
    /// Tracks how security policies affect requests for security posture monitoring
    /// and effectiveness analysis.
    ///
    /// # Labels
    /// * `policy_type`: Type of security policy (rate_limit, authentication, account_lockout)
    /// * `action`: Decision made (allowed, blocked, failed_open)
    /// * `endpoint_group`: Logical API grouping for impact analysis
    pub static ref SECURITY_POLICY_ENFORCEMENTS: CounterVec = register_counter_vec!(
        "security_policy_enforcements_total",
        "Security policy enforcement decisions",
        &["policy_type", "action", "endpoint_group"]
    ).expect("Failed to register security_policy_enforcements_total");

    /// **Performance Metric**: Middleware Processing Duration
    ///
    /// Tracks how long middleware takes to make decisions for performance optimization
    /// and SLA monitoring.
    ///
    /// # Labels
    /// * `middleware_type`: Which middleware is being measured
    /// * `endpoint_group`: Logical API grouping for context
    pub static ref MIDDLEWARE_PROCESSING_DURATION: prometheus::HistogramVec = prometheus::register_histogram_vec!(
        "middleware_processing_duration_seconds",
        "Time spent in middleware processing",
        &["middleware_type", "endpoint_group"],
        vec![0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0]
    ).expect("Failed to register middleware_processing_duration_seconds");
}

static MIDDLEWARE_METRICS_INITIALIZED: AtomicBool = AtomicBool::new(false);

/// Initialize all middleware metrics in a thread-safe manner
pub fn init_middleware_metrics() {
    if MIDDLEWARE_METRICS_INITIALIZED
        .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
        .is_err()
    {
        return;
    }

    lazy_static::initialize(&MIDDLEWARE_HTTP_RESPONSES);
    lazy_static::initialize(&SECURITY_POLICY_ENFORCEMENTS);
    lazy_static::initialize(&MIDDLEWARE_PROCESSING_DURATION);

    log_info!(
        "Metrics",
        "Middleware metrics initialized successfully (HTTP, security, performance)",
        "middleware_metrics_init"
    );
}

// =============================================================================
// HTTP RESPONSE TRACKING API
// =============================================================================

/// Records HTTP response generated by middleware
///
/// # Arguments
/// * `status_code` - HTTP status code (401, 429, 503, etc.)
/// * `middleware_type` - Which middleware generated response ("jwt_auth", "login_guard", "rate_limiter")
/// * `endpoint_group` - Logical grouping ("auth", "protected", "public")
pub fn record_middleware_http_response(
    status_code: u16,
    middleware_type: &str,
    endpoint_group: &str,
) {
    MIDDLEWARE_HTTP_RESPONSES
        .with_label_values(&[&status_code.to_string(), middleware_type, endpoint_group])
        .inc();
}

// =============================================================================
// SECURITY POLICY ENFORCEMENT API
// =============================================================================

/// Records security policy enforcement decision
///
/// # Arguments
/// * `policy_type` - Type of policy ("rate_limit", "authentication", "account_lockout")
/// * `action` - Decision made ("allowed", "blocked", "failed_open")
/// * `endpoint_group` - Logical grouping ("auth", "protected")
pub fn record_security_policy_enforcement(policy_type: &str, action: &str, endpoint_group: &str) {
    SECURITY_POLICY_ENFORCEMENTS
        .with_label_values(&[policy_type, action, endpoint_group])
        .inc();
}

// =============================================================================
// MIDDLEWARE PERFORMANCE TRACKING
// =============================================================================

/// Records middleware processing duration
///
/// # Arguments  
/// * `duration_seconds` - Time spent in middleware
/// * `middleware_type` - Which middleware ("jwt_auth", "login_guard")
/// * `endpoint_group` - Logical grouping ("auth", "protected")
#[allow(dead_code)]
pub fn record_middleware_duration(
    duration_seconds: f64,
    middleware_type: &str,
    endpoint_group: &str,
) {
    MIDDLEWARE_PROCESSING_DURATION
        .with_label_values(&[middleware_type, endpoint_group])
        .observe(duration_seconds);
}

// =============================================================================
// CONVENIENCE FUNCTIONS FOR COMMON SCENARIOS
// =============================================================================

/// JWT Authentication middleware helpers
pub mod jwt_auth {
    use super::*;

    /// Records successful JWT authentication
    pub fn record_success(endpoint_group: &str) {
        record_security_policy_enforcement("authentication", "allowed", endpoint_group);
    }

    /// Records unauthorized JWT authentication with reason
    pub fn record_unauthorized(endpoint_group: &str, reason: &str) {
        record_middleware_http_response(401, "jwt_auth", endpoint_group);
        record_security_policy_enforcement("authentication", "blocked", endpoint_group);
        tracing::debug!(
            "JWT auth blocked: {} for endpoint group: {}",
            reason,
            endpoint_group
        );
    }

    /// Records service unavailable due to dependency issues
    pub fn record_service_unavailable(endpoint_group: &str) {
        record_middleware_http_response(503, "jwt_auth", endpoint_group);
        record_security_policy_enforcement("authentication", "failed_open", endpoint_group);
    }
}

/// Login Guard middleware helpers  
pub mod login_guard {
    use super::*;

    /// Records rate limit exceeded
    pub fn record_rate_limit_blocked(endpoint_group: &str) {
        record_middleware_http_response(429, "login_guard", endpoint_group);
        record_security_policy_enforcement("rate_limit", "blocked", endpoint_group);
    }

    /// Records account lockout block
    pub fn record_account_lockout_blocked(endpoint_group: &str) {
        record_middleware_http_response(401, "login_guard", endpoint_group);
        record_security_policy_enforcement("account_lockout", "blocked", endpoint_group);
    }

    /// Records allowed login attempt
    pub fn record_allowed(endpoint_group: &str) {
        record_security_policy_enforcement("rate_limit", "allowed", endpoint_group);
        record_security_policy_enforcement("account_lockout", "allowed", endpoint_group);
    }

    /// Records when security policies fail open due to Redis unavailability
    #[allow(dead_code)]
    pub fn record_redis_fail_open(endpoint_group: &str) {
        record_security_policy_enforcement("rate_limit", "failed_open", endpoint_group);
        record_security_policy_enforcement("account_lockout", "failed_open", endpoint_group);
    }

    /// Records Redis operation errors during security checks
    pub fn record_redis_error(operation: &str) {
        record_security_policy_enforcement("redis_operation", "failed", "security");
        super::record_middleware_error("login_guard", &format!("redis_{}", operation));
    }

    /// Records request body read errors
    #[allow(dead_code)]
    pub fn record_body_read_error(endpoint_group: &str) {
        record_middleware_http_response(400, "login_guard", endpoint_group);
        record_security_policy_enforcement("request_processing", "failed", endpoint_group);
    }
}

/// Records general middleware errors for tracking operational issues
///
/// # Arguments
/// * `middleware_type` - Which middleware had the error ("jwt_auth", "login_guard", "rate_limiter")
/// * `error_type` - Type of error ("redis_error", "body_read_error", "config_error")
pub fn record_middleware_error(middleware_type: &str, error_type: &str) {
    record_security_policy_enforcement("middleware_operation", "failed", "system");
    MIDDLEWARE_HTTP_RESPONSES
        .with_label_values(&["500", middleware_type, "system"])
        .inc();
    tracing::warn!("Middleware error: {} in {}", error_type, middleware_type);
}

// =============================================================================
// CONSTANTS FOR TYPE SAFETY
// =============================================================================

/// Middleware type constants for type safety
#[allow(dead_code)]
pub mod middleware_types {
    pub const JWT_AUTH: &str = "jwt_auth";
    pub const LOGIN_GUARD: &str = "login_guard";
    pub const RATE_LIMITER: &str = "rate_limiter";
}

/// Endpoint group constants for consistent labeling
#[allow(dead_code)]
pub mod endpoint_groups {
    pub const AUTH: &str = "auth";
    pub const PROTECTED: &str = "protected";
    pub const PUBLIC: &str = "public";
    pub const SYSTEM: &str = "system";
}

/// Policy type constants for security monitoring
#[allow(dead_code)]
pub mod policy_types {
    pub const AUTHENTICATION: &str = "authentication";
    pub const RATE_LIMIT: &str = "rate_limit";
    pub const ACCOUNT_LOCKOUT: &str = "account_lockout";
}

/// Action constants for security decisions
#[allow(dead_code)]
pub mod actions {
    pub const ALLOWED: &str = "allowed";
    pub const BLOCKED: &str = "blocked";
    pub const FAILED_OPEN: &str = "failed_open";
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Once;

    static INIT: Once = Once::new();

    fn init_test_metrics() {
        INIT.call_once(|| {
            init_middleware_metrics();
        });
    }

    #[test]
    fn test_http_response_recording() {
        init_test_metrics();

        // Test various HTTP responses
        record_middleware_http_response(
            401,
            middleware_types::JWT_AUTH,
            endpoint_groups::PROTECTED,
        );
        record_middleware_http_response(429, middleware_types::LOGIN_GUARD, endpoint_groups::AUTH);
        record_middleware_http_response(
            503,
            middleware_types::JWT_AUTH,
            endpoint_groups::PROTECTED,
        );

        // Verify metrics are recorded
        assert_eq!(
            MIDDLEWARE_HTTP_RESPONSES
                .with_label_values(&[
                    "401",
                    middleware_types::JWT_AUTH,
                    endpoint_groups::PROTECTED
                ])
                .get(),
            1.0
        );
        assert_eq!(
            MIDDLEWARE_HTTP_RESPONSES
                .with_label_values(&["429", middleware_types::LOGIN_GUARD, endpoint_groups::AUTH])
                .get(),
            1.0
        );
        assert_eq!(
            MIDDLEWARE_HTTP_RESPONSES
                .with_label_values(&[
                    "503",
                    middleware_types::JWT_AUTH,
                    endpoint_groups::PROTECTED
                ])
                .get(),
            1.0
        );
    }

    #[test]
    fn test_security_policy_enforcement() {
        init_test_metrics();

        // Test different policy decisions
        record_security_policy_enforcement(
            policy_types::RATE_LIMIT,
            actions::BLOCKED,
            endpoint_groups::AUTH,
        );
        record_security_policy_enforcement(
            policy_types::AUTHENTICATION,
            actions::ALLOWED,
            endpoint_groups::PROTECTED,
        );
        record_security_policy_enforcement(
            policy_types::ACCOUNT_LOCKOUT,
            actions::FAILED_OPEN,
            endpoint_groups::AUTH,
        );

        // Verify metrics
        assert_eq!(
            SECURITY_POLICY_ENFORCEMENTS
                .with_label_values(&[
                    policy_types::RATE_LIMIT,
                    actions::BLOCKED,
                    endpoint_groups::AUTH
                ])
                .get(),
            1.0
        );
        assert_eq!(
            SECURITY_POLICY_ENFORCEMENTS
                .with_label_values(&[
                    policy_types::AUTHENTICATION,
                    actions::ALLOWED,
                    endpoint_groups::PROTECTED
                ])
                .get(),
            1.0
        );
        assert_eq!(
            SECURITY_POLICY_ENFORCEMENTS
                .with_label_values(&[
                    policy_types::ACCOUNT_LOCKOUT,
                    actions::FAILED_OPEN,
                    endpoint_groups::AUTH
                ])
                .get(),
            1.0
        );
    }

    #[test]
    fn test_convenience_functions() {
        init_test_metrics();

        // Test JWT auth helpers
        jwt_auth::record_success(endpoint_groups::PROTECTED);
        jwt_auth::record_unauthorized(endpoint_groups::PROTECTED, "test_failure");
        jwt_auth::record_service_unavailable(endpoint_groups::PROTECTED);

        // Test login guard helpers
        login_guard::record_rate_limit_blocked(endpoint_groups::AUTH);
        login_guard::record_account_lockout_blocked(endpoint_groups::AUTH);
        login_guard::record_allowed(endpoint_groups::AUTH);

        // Verify JWT auth metrics
        assert_eq!(
            SECURITY_POLICY_ENFORCEMENTS
                .with_label_values(&[
                    policy_types::AUTHENTICATION,
                    actions::ALLOWED,
                    endpoint_groups::PROTECTED
                ])
                .get(),
            1.0
        );
        assert_eq!(
            MIDDLEWARE_HTTP_RESPONSES
                .with_label_values(&[
                    "401",
                    middleware_types::JWT_AUTH,
                    endpoint_groups::PROTECTED
                ])
                .get(),
            1.0
        );

        // Verify login guard metrics
        assert_eq!(
            MIDDLEWARE_HTTP_RESPONSES
                .with_label_values(&["429", middleware_types::LOGIN_GUARD, endpoint_groups::AUTH])
                .get(),
            1.0
        );
        assert_eq!(
            SECURITY_POLICY_ENFORCEMENTS
                .with_label_values(&[
                    policy_types::RATE_LIMIT,
                    actions::BLOCKED,
                    endpoint_groups::AUTH
                ])
                .get(),
            1.0
        );
    }

    #[test]
    fn test_middleware_duration_recording() {
        init_test_metrics();

        // Record various durations
        record_middleware_duration(0.05, middleware_types::JWT_AUTH, endpoint_groups::PROTECTED);
        record_middleware_duration(0.001, middleware_types::LOGIN_GUARD, endpoint_groups::AUTH);
        record_middleware_duration(0.1, middleware_types::JWT_AUTH, endpoint_groups::PROTECTED);

        // Verify histogram recorded values (sample count should be 2 for jwt_auth/protected)
        let histogram = MIDDLEWARE_PROCESSING_DURATION
            .with_label_values(&[middleware_types::JWT_AUTH, endpoint_groups::PROTECTED]);
        assert_eq!(histogram.get_sample_count(), 2);
    }
}
